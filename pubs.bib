@inproceedings{mastrangelo19,
  title = {{{Casting about in the Dark: A Survey of Cast Usage in Java}}},
  author = {\textbf{Mastrangelo}, \textbf{Luis} and Hauswirth, M. and Nystrom, N.},
  year = {2019}
}

@inproceedings{mastrangeloUseYourOwn2015,
  title = {Use at {{Your Own Risk}}: {{The Java Unsafe API}} in the {{Wild}}},
  isbn = {978-1-4503-3689-5},
  shorttitle = {Use at {{Your Own Risk}}},
  abstract = {Java is a safe language. Its runtime environment provides strong safety guarantees that any Java application can rely on. Or so we think. We show that the runtime actually does not provide these guarantees---for a large fraction of today's Java code. Unbeknownst to many application developers, the Java runtime includes a "backdoor" that allows expert library and framework developers to circumvent Java's safety guarantees. This backdoor is there by design, and is well known to experts, as it enables them to write high-performance "systems-level" code in Java. For much the same reasons that safe languages are preferred over unsafe languages, these powerful---but unsafe---capabilities in Java should be restricted. They should be made safe by changing the language, the runtime system, or the libraries. At the very least, their use should be restricted. This paper is a step in that direction. We analyzed 74 GB of compiled Java code, spread over 86,479 Java archives, to determine how Java's unsafe capabilities are used in real-world libraries and applications. We found that 25\% of Java bytecode archives depend on unsafe third-party Java code, and thus Java's safety guarantees cannot be trusted. We identify 14 different usage patterns of Java's unsafe capabilities, and we provide supporting evidence for why real-world code needs these capabilities. Our long-term goal is to provide a foundation for the design of new language features to regain safety in Java.},
  doi = {10.1145/2814270.2814313},
  author = {\textbf{Mastrangelo}, \textbf{Luis} and Ponzanelli, L. and Mocci, A. and Lanza, M. and Hauswirth, M. and Nystrom, N.},
  year = {2015},
  keywords = {Java,patterns,mining,Maven Central,Stack Overflow,unsafe},
}

@inproceedings{Mastrangelo:2014:JJN:2647508.2647516,
 author = {\textbf{Mastrangelo}, \textbf{Luis} and Hauswirth, M.},
 title = {{{JNIF}}: {{Java Native Instrumentation Framework}}},
 year = {2014},
 isbn = {978-1-4503-2926-2},
 location = {Cracow, Poland},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/2647508.2647516},
 doi = {10.1145/2647508.2647516},
 acmid = {2647516},
 keywords = {Java, bytecode instrumentation, program analysis},
}

@inproceedings{pub4,
    hal_id = {hal-00664345},
    url = {http://hal.inria.fr/hal-00664345},
    title = {{VMAD: an Advanced Dynamic Program Analysis \& Instrumentation Framework}},
    author = {Jimborean, A. and \textbf{Mastrangelo}, \textbf{Luis} and Loechner, V. and Clauss, P.},
    language = {Anglais},
    affiliation = {CAMUS - INRIA Lorraine , Laboratoire de Sciences de l'Image, de l'Informatique et de la T{\'e}l{\'e}d{\'e}tection, {\'e}quipe ICPS - LSIIT / ICPS},
    year = {2012},
}

@inproceedings{pub5,
 author = {Jimborean, A. and Clauss, P. and Pradelle, B. and \textbf{Mastrangelo}, \textbf{Luis} and Loechner, V.},
 title = {Adapting the polyhedral model for efficient speculative parallelization},
 year = {2012},
 isbn = {978-1-4503-1160-1},
 location = {New Orleans, Louisiana, USA},
 numpages = {2},
 url = {http://doi.acm.org/10.1145/2145816.2145861},
 doi = {10.1145/2145816.2145861},
 acmid = {2145861}
} 